# A compiler for the TEST language written in Rust

# How to use
  1.Use 'git clone https://github.com/zel2023/rust_compiler.git' command to clone this repo.  
  2.Use `cargo build` and `cargo run` to  start the compiler.

# File Orginization  
  There are three folders: 'dataset', 'src' and 'target'.

  * **dataset**  
  It is used to store some source code files written in TEST.

  * **src**  
  It is used to store the core code files of the compiler.  
  1.word_analysis.rs: A file that implements lexical analysis.  
  2.syntax.rs: A file for syntax, semantic analysis, and code generation.  
  3.virtual_machine.rs: A file that implements a simple virtual machine.  
  4.main.rs: A file to start the compiler.  

  * **target**  
  It is automatically generated by Cargo to store intermediate files during the compilation process and final generated binaries.

# Lexical Rules of the TEST Language  
1.Identifiers: Start with a letter, followed by letters or digits. Identified identifiers are marked as ID.  
2.Keywords (which are a subset of identifiers): if, else, for, while, do, int, write, read, switch, case, break, default. Identified keywords are marked directly with the keyword itself. Keywords are case-insensitive.  
3.Unsigned Integers: Composed of digits and marked as NUM.  
4.Delimiters: Single delimiters such as +, -, *, /, (, ), ;, ,, >, <, {, }, !, etc. are marked directly with the corresponding delimiter. Double delimiters such as >=, <=, !=, ==, &&, || are marked directly with the corresponding double delimiter.  
The regular grammar rules for each type of lexical symbol in the TEST language are as follows:  

```
(1) <ID>∷=<letter>|<ID><letter>|<ID><digit>
(2) <NUM>∷=<digit>|<NUM> <digit>
(3) <letter>∷= a|b|…|z|A|B|…|Z
(4) <digit>∷=1|2|…|9|0
(5) <singleword>∷= + | - | * | / | = |（|）|{ | }|：|，|；| ＜ | ＞| !|&| |
(6) <doubleword>∷= ＞= |＜= | != | ==|&&| ||
```

# Syntax Rules of the TEST Language  
The last declaration in the program must be a function definition named main, with no prototype declaration. Convention: The definition of called functions must appear before the definition of the calling function.  
```
(1). <program> →{ fun_declaration }<main_declaration> 
(2). <fun_declaration> → function ID’(‘ ‘ )’< function_body> 
(3). <main_declaration>→main’(‘ ‘ )’ < function_body> 
(4). <function_body>→ ‘{‘<declaration_list><statement_list>’}’ 
(5). <declaration_list>→<declaration_list><declaration_stat> |ε  ; <declaration_list>→{<declaration_stat>} 
(6). <declaration_stat>→int ID; 
(7). <statement_list>→<statement_list><statement>| ε ;  <statement_list>→{<statement>} 
(8). <statement>→<if_stat>|<while_stat>|<for_stat>|<read_stat> |<write_stat>|<compound_stat> |<expression_stat> | < call _stat> 
(9). <if_stat>→ if ‘(‘<expr>’)’ <statement > [else < statement >] 
(10). <while_stat>→ while ‘(‘<expr >’)’ < statement > 
(11). <for_stat>→ for’(‘<expr>;<expr>;<expr>’)’<statement>
(12). <write_stat>→write <expression>; 
(13). <read_stat>→read ID; 
(14). <compound_stat>→’{‘<statement_list>’}’ 
(15). <expression_stat>→< expression >;|; 
(16). < call _stat>→ call ID‘(’ ‘)’ 
(17). < expression >→ ID=<bool_expr>|<bool_expr> 
(18). <bool_expr>-><additive_expr>|<additive_expr>(>|<|>=|<=|==|!=)<additive_expr> 
(19). <bool_expr>→<additive_expr>{(>|<|>=|<=|==|!=)<additive_expr>} 
(20). < additive_expr>→<term>{(+|-)< term >} 
(21). < term >→<factor>{(*| /)< factor >} 
(22). < factor >→’(‘< additive_expr >’)’|ID|NUM 

```

