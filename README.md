# A compiler for the TEST language written in Rust

# How to use
  1.Use 'git clone https://github.com/zel2023/rust_compiler.git' command to clone this repo.  
  2.Use 'cargo build' and 'cargo run' to  start the compiler.

# File Orginization  
  There are three folders: 'dataset', 'src' and 'target'.

  * **dataset**  
  It is used to store some source code files written in TEST.

  * **src**  
  It is used to store the core code files of the compiler.  
  1.word_analysis.rs: A file that implements lexical analysis.  
  2.syntax.rs: A file for syntax, semantic analysis, and code generation.  
  3.virtual_machine.rs: A file that implements a simple virtual machine.  
  4.main.rs: A file to start the compiler.  

  * **target**  
  It is automatically generated by Cargo to store intermediate files during the compilation process and final generated binaries.

# Lexical Rules of the TEST Language  
1.Identifiers: Start with a letter, followed by letters or digits. Identified identifiers are marked as ID.  
2.Keywords (which are a subset of identifiers): if, else, for, while, do, int, write, read, switch, case, break, default. Identified keywords are marked directly with the keyword itself. Keywords are case-insensitive.  
3.Unsigned Integers: Composed of digits and marked as NUM.  
4.Delimiters: Single delimiters such as +, -, *, /, (, ), ;, ,, >, <, {, }, !, etc. are marked directly with the corresponding delimiter. Double delimiters such as >=, <=, !=, ==, &&, || are marked directly with the corresponding double delimiter.  
The regular grammar rules for each type of lexical symbol in the TEST language are as follows:  

```
(1) <ID>∷=<letter>|<ID><letter>|<ID><digit>
(2) <NUM>∷=<digit>|<NUM> <digit>
(3) <letter>∷= a|b|…|z|A|B|…|Z
(4) <digit>∷=1|2|…|9|0
(5) <singleword>∷= + | - | * | / | = |（|）|{ | }|：|，|；| ＜ | ＞| !|&| |
(6) <doubleword>∷= ＞= |＜= | != | ==|&&| ||
```

# Syntax Rules of the TEST Language  
The last declaration in the program must be a function definition named main, with no prototype declaration. Convention: The definition of called functions must appear before the definition of the calling function.  
```
(1). <program> →{ fun_declaration }<main_declaration> 
(2). <fun_declaration> → function ID’(‘ ‘ )’< function_body> 
(3). <main_declaration>→main’(‘ ‘ )’ < function_body> 
(4). <function_body>→ ‘{‘<declaration_list><statement_list>’}’ 
(5). <declaration_list>→<declaration_list><declaration_stat> |ε  ; <declaration_list>→{<declaration_stat>} 
(6). <declaration_stat>→int ID; 
(7). <statement_list>→<statement_list><statement>| ε ;  <statement_list>→{<statement>} 
(8). <statement>→<if_stat>|<while_stat>|<for_stat>|<read_stat> |<write_stat>|<compound_stat> |<expression_stat> | < call _stat> 
(9). <if_stat>→ if ‘(‘<expr>’)’ <statement > [else < statement >] 
(10). <while_stat>→ while ‘(‘<expr >’)’ < statement > 
(11). <for_stat>→ for’(‘<expr>;<expr>;<expr>’)’<statement>
(12). <write_stat>→write <expression>; 
(13). <read_stat>→read ID; 
(14). <compound_stat>→’{‘<statement_list>’}’ 
(15). <expression_stat>→< expression >;|; 
(16). < call _stat>→ call ID‘(’ ‘)’ 
(17). < expression >→ ID=<bool_expr>|<bool_expr> 
(18). <bool_expr>-><additive_expr>|<additive_expr>(>|<|>=|<=|==|!=)<additive_expr> 
(19). <bool_expr>→<additive_expr>{(>|<|>=|<=|==|!=)<additive_expr>} 
(20). < additive_expr>→<term>{(+|-)< term >} 
(21). < term >→<factor>{(*| /)< factor >} 
(22). < factor >→’(‘< additive_expr >’)’|ID|NUM 

```



```
(1)LOAD:    Load data from a relative position of the current base address to the top of the stack.  
(2)LOADI:   Load an immediate value onto the top of the stack.  
(3)STO:     Store the top of the stack data into a relative position of the current base address.  
(4)STI:     Store the top of the stack data into the address located just below the top of the stack.  
(5)ADD:     Pop the top two stack values, compute their sum, and push the result onto the stack.  
(6)SUB:     Pop the top two stack values, compute the result of the first minus the second, and push it onto the stack.  
(7)MULT:    Pop the top two stack values, compute their product, and push the result onto the stack.  
(8)DIV:     Pop the top two stack values, compute the result of the first divided by the second, and push it onto the stack.  
(9)BR:      Unconditionally jump to the specified instruction address.  
(10)BRF:    Conditional jump: if the top of the stack is 0, jump to the specified instruction address.  
(11)EQ:     Compare the top two stack values for equality. Push 1 if equal, otherwise push 0.  
(12)NOTEQ:  Compare the top two stack values for inequality. Push 1 if not equal, otherwise push 0.  
(13)GT:     Compare the top two stack values. Push 1 if the first is greater than the second, otherwise push 0.  
(14)LES:    Compare the top two stack values. Push 1 if the first is less than the second, otherwise push 0.  
(15)GE:     Compare the top two stack values. Push 1 if the first is greater than or equal to the second, otherwise push 0.  
(16)LE:     Compare the top two stack values. Push 1 if the first is less than or equal to the second, otherwise push 0.  
(17)AND:    Pop the top two stack values and compute their logical AND. Push the result onto the stack.  
(18)OR:     Pop the top two stack values and compute their logical OR. Push the result onto the stack.  
(19)NOT:    Perform logical NOT on the top of the stack. Push the result back onto the stack.  
(20)IN:     Read data from standard input and push it onto the stack.  
(21)OUT:    Pop the top of the stack and output its value to the standard output device.  
(22)RETURN: Return from the current function, freeing its stack space and restoring the base address and instruction pointer.  
(23)ENTER:  Allocate stack space for the called function.  
(24)CAL:    Call a function, saving the current base address and return address, then jump to the function's entry point.  
(25)PAS:    Pass parameters by transferring them from the stack top to the function's call stack space.  


```






